<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/1.svg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/1.svg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="白马？定叫他有来无回！">
<meta property="og:type" content="website">
<meta property="og:title" content="WeFun blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="WeFun blog">
<meta property="og:description" content="白马？定叫他有来无回！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Plank">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>WeFun blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">WeFun blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/19/%E8%BF%9B%E5%8C%96%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BE%8E%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Plank">
      <meta itemprop="description" content="白马？定叫他有来无回！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeFun blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/19/%E8%BF%9B%E5%8C%96%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BE%8E%E5%8C%96/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-19 15:53:23 / 修改时间：15:08:52" itemprop="dateCreated datePublished" datetime="2025-05-19T15:53:23+08:00">2025-05-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进化树的构建与美化"><a href="#进化树的构建与美化" class="headerlink" title="进化树的构建与美化"></a>进化树的构建与美化</h1><pre><code>构建进化树常常有多种办法，常用的有邻接法（NJ），UMPGA，最大简约法（MP），最大似然法（ML），贝叶斯法，不同方法各有其优缺点，最常用的就是ML和贝叶斯法，各个方法的原理及优缺点不在此处进行赘述，以下仅介绍建树的具体流程
</code></pre>
<p>构建进化树一般分为两步，第一步进行多序列比对，第二步对比对结果建树。</p>
<h2 id="1-多序列比对"><a href="#1-多序列比对" class="headerlink" title="1.多序列比对"></a>1.多序列比对</h2><p>多序列比对常用多序列比对常用软件为 muscle 和 mafft, 这里使用 muscle。github下载链接为<a target="_blank" rel="noopener" href="https://github.com/rcedgar/muscle/archive/refs/tags/v5.3.tar.gz%EF%BC%8C%E5%AE%98%E7%BD%91%E4%BD%8D%E7%BD%AE%E4%B8%BAhttps://github.com/rcedgar/muscle">https://github.com/rcedgar/muscle/archive/refs/tags/v5.3.tar.gz，官网位置为https://github.com/rcedgar/muscle</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">muscle -in all_FAD.fasta -out all_FAD.muscle.fasta</span><br><span class="line">#all_FAD.fasta为建树物种共同的某一基因家族的序列组合，为蛋白质序列</span><br></pre></td></tr></table></figure>

<p>如果想要使用mafft可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#高速模式</span><br><span class="line">mafft in &gt; out</span><br><span class="line">#高准确性模式（序列&lt;200，aa/nt&lt;2000）</span><br><span class="line">mafft --maxiterate 1000 --localpair in &gt; out</span><br><span class="line">mafft --maxiterate 1000 --genafpair in &gt; out</span><br><span class="line">mafft --maxiterate 1000 --globarpair in &gt; out</span><br></pre></td></tr></table></figure>

<h2 id="2-构建进化树"><a href="#2-构建进化树" class="headerlink" title="2.构建进化树"></a>2.构建进化树</h2><p>RAxML 是一款基于最大似然法构建系统发育树的软件，运算速度较快，推荐使用。RAxML 的输入文件为多序列比对文件，phylip 格式或者 fasta格式，输出文件为 newick 格式进化树<br>软件下载位置：<a target="_blank" rel="noopener" href="https://cme.h-its.org/exelixis/web/software/raxml/hands_on.html">https://cme.h-its.org/exelixis/web/software/raxml/hands_on.html</a><br>下载好后可以看到，有raxmlHPC和raxmlHPC-PHREADS 分别为单线程和多线程版本，一般使用后者  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">raxmlHPC-PTHREADS -m PROTGAMMAJTT -f a -p 123 -x 123 -# 100 -n out -s all_FAD.muscle.fasta 1&gt;tree.log 2&gt;tree.err</span><br><span class="line"></span><br><span class="line">-m PROTGAMMAJTT \ # 指定建树模型，PROT表示输入为蛋白质，GAMMA表示离散位点使用的估计方式，JTT表示氨基酸模型</span><br><span class="line">-f a \ # 指定算法，a表示使用rapidBootstrap方法并搜索最佳ML树</span><br><span class="line">-p 123 \ # parsimonyRandomSeed，随机数种子</span><br><span class="line">-x 123 \ # rapidBoostrap时RandomNumberSeed，随机数种子</span><br><span class="line">-# 100 \ # bootstrap次数</span><br><span class="line">-n out \ # 指定输出文件后缀</span><br><span class="line">-s all_FAD.muscle.fasta \ # 指定输入的比对文件</span><br><span class="line">1&gt;tree.log 2&gt;tree.err#存储日志</span><br><span class="line">-T增加线程数，默认为2</span><br></pre></td></tr></table></figure>
<p><strong>#使用iqtree构建</strong><br>iqtree 可以自动估计最佳模型，并进行 bootstrap 分析，也是一款推荐的建树软件。软件网址：<a target="_blank" rel="noopener" href="http://www.iqtree.org/">http://www.iqtree.org/</a>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iqtree -s all_FAD.muscle.fasta -m MFP -bb 1000 -nt 4-pre iqtree.all_FAD.muscle.fasta</span><br><span class="line">-s all_FAD.muscle.fasta \ # 指定输入的比对文件</span><br><span class="line">-m MFP \ # iqtree自动选择模型</span><br><span class="line">-bb 1000 \ # bootstrap分析次数，至少是1000</span><br><span class="line">-nt 4 \ # 线程数</span><br><span class="line">-pre iqtree.all_FAD.muscle.fasta # 输出文件前缀</span><br></pre></td></tr></table></figure>
<p>通常情况下我们无法直接获得建树物种共同的某一基因家族的序列的组合，此时我们可以借助之前orthofinder的结果来进行构建物种树，ortherfinder操作具体教程详见《查找共有和独有基因》  </p>
<p>构建树的方式有两种，一种是使用连接法&#x2F;串联法，将某一物种的所有单拷贝基因基因家族连接成一整条序列（supergene），每一物种都进行类似操作之后进行建树<br>另一种是合并法，每一个基因家族单独建树，总结其中出现次数最多的建树情况，然后将这种情况当作是最终结果</p>
<p>使用连接法时可以将pep文件转成CDS序列文件，再进行序列比对，进而进行建树，这种方式通常用于亲缘关系较近的物种建树  </p>
<p>还可以使用4d位点，4d位点指四重简并位点，该一位点不论是ATCG中的任意碱基都不影响该蛋白质的编码，仅保留4d位点的序列可以减少比对时的数据量，进而提升建树速度及准确度</p>
<p>orthofinder使用msa的建树使用的就是连接法，不加msa使用的就是合并法，通常情况下建议使用msa参数</p>
<p>假设单拷贝基因家族的数量太少，此时可以将条件放宽，认为不是所有物种都具有的单拷贝基因家族才为共有，即假设共有10个物种，9个物种具有该基因家族，仍认为这是共有单拷贝基因家族</p>
<p><strong>串联法</strong><br>单拷贝基因家族位置为：data&#x2F;OrthoFinder&#x2F;Results_May14&#x2F;MultipleSequenceAlignments&#x2F;SpeciesTreeAlignment.fa</p>
<p>如果某一些位置的比对结果较差，可以选择将较差的部分删掉，可以使用trimal，基因树一般需要进行此操作，物种树一般不需要进行此操作  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/scapella/trimal.git</span><br><span class="line">cd trimal/source</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">trimal -in SpeciesTreeAlignment.fa -out SpeciesTreeAlignment_trim.fa -fasta -gt 0.6 -cons 60 </span><br><span class="line"></span><br><span class="line">-gt 0.6 #保留60%基因共有的位点</span><br><span class="line">-cons 60 # 过滤后总长不少于输入数据的60%</span><br><span class="line"></span><br><span class="line">-fasta可替换</span><br><span class="line">-CUSTAL格式的-clustal输出文件</span><br><span class="line">-nbrf NBRF / PIR格式的输出文件</span><br><span class="line">-nexus NEXUS格式的输出文件</span><br><span class="line">-mega MEGA格式的输出文件</span><br><span class="line">-phylip3.2 PHYLIP3.2格式的输出文件</span><br><span class="line">-phylip PHYLIP / PHYLIP4格式的输出文件</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raxmlHPC-PTHREADS -m PROTGAMMAJTT -f a -p 123 -x 123 -# 100 -n out  -T 20 -s SpeciesTreeAlignment.fa 1&gt;tree.log 2&gt;tree.err</span><br></pre></td></tr></table></figure>
<p>参数与上一致，不过多赘述</p>
<p><strong>合并法</strong><br>orthofinder已自建各基因家族树，位置为data&#x2F;OrthoFinder&#x2F;Results_Dec03&#x2F;Orthogroups&#x2F;Orthogroups_SingleCopyOrthologues.txt</p>
<p>先安装Astral</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/smirarab/ASTRAL.git</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#先使用脚本提取单拷贝基因树</span><br><span class="line">orthDir=data3/OrthoFinder/Results_Dec03/</span><br><span class="line">cat $orthDir/Orthogroups/Orthogroups_SingleCopyOrthologues.txt | \</span><br><span class="line">while read aa; \</span><br><span class="line">do cat $orthDir/Gene_Trees/$aa\_tree.txt | \</span><br><span class="line">awk &#x27;&#123;print $0&#125;&#x27; ;\</span><br><span class="line">done &gt; SingleCopy.trees</span><br><span class="line"></span><br><span class="line">#去除基因ID，保留物种名</span><br><span class="line">sed &#x27;s/\([(,][A-Za-z]\+\)_[^:]*/\1/g&#x27; SingleCopy.trees &gt; Astral_input.trees</span><br><span class="line"></span><br><span class="line">#运行Astral</span><br><span class="line">java -jar astral.5.7.8.jar -i Astral_input.trees -o Astral_output.tree 2&gt;out.log</span><br></pre></td></tr></table></figure>
<p>如果物种树较多，astral会出现内存不够的情况，实际测试时使用-Xmx300G添加了300G内存仍显示内存不足  </p>
<p>如果Orthogroups_SingleCopyOrthologues.txt为空，需要放宽标准，选取90%或者95%的物种有的单拷贝同源序列可以使用脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line">def extract_high_coverage_single_copy_orthogroups(orthogroups_file, output_file, coverage_threshold=0.95):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    从Orthogroups.tsv中提取覆盖率达到指定阈值(默认95%)且为单拷贝的直系同源组</span><br><span class="line">    </span><br><span class="line">    参数:</span><br><span class="line">        orthogroups_file: Orthogroups.tsv文件路径</span><br><span class="line">        output_file: 输出文件路径</span><br><span class="line">        coverage_threshold: 覆盖率阈值(0-1之间)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 读取Orthogroups.tsv文件</span><br><span class="line">    df = pd.read_csv(orthogroups_file, sep=&#x27;\t&#x27;, index_col=0)</span><br><span class="line">    </span><br><span class="line">    # 计算每个直系同源组的覆盖率(非空值的比例)</span><br><span class="line">    coverage = df.notnull().mean(axis=1)</span><br><span class="line">    </span><br><span class="line">    # 检查每个直系同源组是否为单拷贝</span><br><span class="line">    def is_single_copy(row):</span><br><span class="line">        # 对每个物种的基因计数，逗号分隔表示多拷贝</span><br><span class="line">        for genes in row.dropna():</span><br><span class="line">            if &#x27;,&#x27; in str(genes):  # 如果有逗号，表示该物种有多个拷贝</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br><span class="line">    </span><br><span class="line">    # 应用单拷贝检查</span><br><span class="line">    single_copy_mask = df.apply(is_single_copy, axis=1)</span><br><span class="line">    </span><br><span class="line">    # 筛选同时满足高覆盖率和单拷贝条件的直系同源组</span><br><span class="line">    high_coverage_single_copy = coverage[(coverage &gt;= coverage_threshold) &amp; single_copy_mask].index</span><br><span class="line">    </span><br><span class="line">    # 保存结果到文件</span><br><span class="line">    with open(output_file, &#x27;w&#x27;) as f:</span><br><span class="line">        for og in high_coverage_single_copy:</span><br><span class="line">            f.write(f&quot;&#123;og&#125;\n&quot;)</span><br><span class="line">    </span><br><span class="line">    print(f&quot;找到 &#123;len(high_coverage_single_copy)&#125; 个覆盖率达到 &#123;coverage_threshold*100&#125;% 的单拷贝直系同源组&quot;)</span><br><span class="line">    print(f&quot;结果已保存到 &#123;output_file&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    import argparse</span><br><span class="line">    </span><br><span class="line">    parser = argparse.ArgumentParser(description=&#x27;提取覆盖率达到指定阈值且为单拷贝的直系同源组&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-i&#x27;, &#x27;--input&#x27;, required=True, help=&#x27;Orthogroups.tsv文件路径&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-o&#x27;, &#x27;--output&#x27;, required=True, help=&#x27;输出文件路径&#x27;)</span><br><span class="line">    parser.add_argument(&#x27;-t&#x27;, &#x27;--threshold&#x27;, type=float, default=0.95, </span><br><span class="line">                        help=&#x27;覆盖率阈值(0-1之间，默认0.95)&#x27;)</span><br><span class="line">    </span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    extract_high_coverage_single_copy_orthogroups(args.input, args.output, args.threshold)</span><br></pre></td></tr></table></figure>
<p>该python脚本是针对终端而写，使用方式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python extract_high_coverage_ogs.py -i Orthogroups.tsv -o SingleCopyOrthologues.txt -t 0.95</span><br></pre></td></tr></table></figure>

<h2 id="3-进化树的美化"><a href="#3-进化树的美化" class="headerlink" title="3.进化树的美化"></a>3.进化树的美化</h2><p>进化树构建完成之后美化方式有多种，MEGA，FigTree等软件，在线网站EvolView，ITOL等等，以下介绍ITOL网站，功能全面，客制化能力强<br>ITOL网址为：<a target="_blank" rel="noopener" href="https://itol.embl.de/">https://itol.embl.de/</a><br>该软件 2020 年 10 月由免费软件转为收费，访问模式可以使用，但不能保存注释，必须立即导出。基本的树结构调整以及字体调整可以通过 control面板实现，添加 symbol、饼图及条形图等，需要自己准备好 dataset 文件。<br>首先根据之前的建树结果得到树文件，RAxML运行结果中树文件名为RAxML_bipartitionsBranchLabels.out<br>如果想在图中添加更多的信息，就需要自己准备好配置文件，将文件拖拽到进化树美化页面。<br>然后可以根据需要准备以下文件：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">##color_label.txt（展示文字的颜色）:</span><br><span class="line"># 指定dataset类型</span><br><span class="line">TREE_COLORS</span><br><span class="line"># 指定文件分隔符</span><br><span class="line">SEPARATOR TAB</span><br><span class="line"># 指定数据，第一列为label，</span><br><span class="line"># 第二列写为&quot;label&quot;</span><br><span class="line"># 第三列为颜色</span><br><span class="line"># 第四列为字体</span><br><span class="line"># 第五列为字体大小</span><br><span class="line">DATA</span><br><span class="line">##color_range.txt（展示文字的背景色）:</span><br><span class="line">##binary.txt（额外标记）:</span><br><span class="line">##barchat.txt（直方图）:</span><br><span class="line">##piechat.txt（饼图）:</span><br></pre></td></tr></table></figure>
<p>准备好文件之后，打开ITOL，点击annotate下upload a tree，可以选择直接复制树文件内容，也可以上传文件。完成之后可以显示最初的进化树。<br>进化树如果是物种树一般需要定根，否则显示的是无根树，定根只需要在相应的节点点击，选择tree structure-&gt;re-root the tree here即可。  </p>
<p>其余在右侧control panel中的各个参数可以根据自己的需要进行选择，选择好之后只需要将其他配置文件拖入网页中即可添加其他的注释信息。<br>其他具体的信息可以看ITOL网站的help信息。  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/19/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F%E6%89%A9%E5%BC%A0%E6%94%B6%E7%BC%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Plank">
      <meta itemprop="description" content="白马？定叫他有来无回！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeFun blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/19/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F%E6%89%A9%E5%BC%A0%E6%94%B6%E7%BC%A9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-19 15:53:23 / 修改时间：15:36:18" itemprop="dateCreated datePublished" datetime="2025-05-19T15:53:23+08:00">2025-05-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基因家族扩张收缩"><a href="#基因家族扩张收缩" class="headerlink" title="基因家族扩张收缩"></a>基因家族扩张收缩</h1><p>基因家族指来自大部份物种的MRCA（最近共同祖先，Most Recent Common Ancestor）的同一个始祖基因演化而来的一组基因。<br>CAFE(Computational Analysis of gene Family Evolution)是一款以解释系统发育历史的方式分析基因家族大小变化的软件，这种分析常被称为基因家族收缩扩张(Gene family expansions and contractions)分析。2005年该软件相关算法就已经发表，最近一次更新在2023年。CAFE使用出生和死亡过程来模拟用户指定的系统发育树中的基因获得和丢失（获得替换率，λ），2017年时首次提出不同枝基因的出生死亡率不同，这样可以算出父节点到子节点的基因家族大小转移率，也可推断祖先物种的基因家族大小<br>研究基因家族在进化过程中的大小变化，即关注旁系同源基因的演化，本次教程主要来源： <a target="_blank" rel="noopener" href="https://yanzhongsino.github.io/2021/10/29/bioinfo_gene.family_CAFE5/">https://yanzhongsino.github.io/2021/10/29/bioinfo_gene.family_CAFE5/</a> </p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c bioconda cafe</span><br></pre></td></tr></table></figure>
<p>安装的是CAFE4<br>直接上官网安装可以安装到最新版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/hahnlab/CAFE5.git</span><br><span class="line">cd CAFE5</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果遇到报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 -I. -O3 -include config.h -DDOCTEST_CONFIG_DISABLE -fopenmp  -c src/matrix_cache.cpp -o obj/matrix_cache.o</span><br><span class="line">src/matrix_cache.cpp:12:10: fatal error: cblas.h: No such file or directory</span><br><span class="line">   12 | #include &quot;cblas.h&quot;</span><br><span class="line">      |          ^~~~~~~~~</span><br><span class="line">compilation terminated.</span><br><span class="line">make: *** [Makefile:35: obj/matrix_cache.o] Error 1</span><br></pre></td></tr></table></figure>
<p>这是因为缺少数学运算程序，只需要安装blas和lapack即可，主要教程为： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/520848641">https://zhuanlan.zhihu.com/p/520848641</a><br>blas已经包括在lapack中，因此只需要下载lapack即可  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#下载LAPACK</span><br><span class="line">wget https://github.com/Reference-LAPACK/lapack/archive/refs/tags/v3.12.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压完成之后进入lapack-3.12.1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd lapack-3.12.1</span><br><span class="line">cp make.inc.example make.inc</span><br><span class="line">make blaslib</span><br><span class="line">make cblaslib</span><br><span class="line">make lapacklib</span><br><span class="line">make lapackelib</span><br></pre></td></tr></table></figure>
<p>编译完成之后将静态库加入到环境变量即可（没有root权限）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LIBRARY_PATH=&quot;$LIBRARY_PATH:/xxx/lapack-3.10.1&quot;</span><br><span class="line">export C_INCLUDE_PATH=&quot;$C_INCLUDE_PATH:/xxx/lapack-3.10.1/LAPACKE/include:/xxx/lapack-3.10.1/CBLAS/include&quot;</span><br></pre></td></tr></table></figure>
<p>除此之外，还需要将CAFE5&#x2F;makefile文件开头部分加上cblas.h位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -I/home/walnut168/mnt/wf/program/lapack-3.12.1/CBLAS/include</span><br></pre></td></tr></table></figure>
<h2 id="2-准备文件"><a href="#2-准备文件" class="headerlink" title="2.准备文件"></a>2.准备文件</h2><p>CAFE5需要至少两个输入文件，一个是基因家族计数文件gene_families.txt，一个是树文件tree.txt</p>
<h3 id="2-1gene-families-txt"><a href="#2-1gene-families-txt" class="headerlink" title="2.1gene_families.txt"></a>2.1gene_families.txt</h3><p>制表符分隔的基因家族计数文件，通常用OrthoMCL, SwiftOrtho, FastOrtho, OrthAgogue, OrthoFinder等软件获取，因此可以直接使用OrthoFinder的Orthogroups.GeneCount.tsv文件来获得<br>文件位置为&#x2F;data&#x2F;OrthoFinder&#x2F;Results_Apr21&#x2F;Orthogroups&#x2F;Orthogroups.GeneCount.tsv  </p>
<p>CAFE给的示例文件文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#第一列是功能描述Desc，不清楚可以写为null，第二列是Family ID</span><br><span class="line">Desc	Family ID	human	chimp	orang	baboon	gibbon	macaque	marmoset rat	mouse	cat	horse	cow</span><br><span class="line">ATPase	ORTHOMCL1	 52	 55	 54	 57	 54	  56	  56	 53	 52	57	55	 54</span><br><span class="line">(null)	ORTHOMCL2	 76	 51	 41	 39	 45	  36	  37	 67	 79	37	41	 49</span><br><span class="line">HMG box	ORTHOMCL3	 50	 49	 48	 48	 46	  49	  48	 55	 52	51	47	 55</span><br><span class="line">(null)	ORTHOMCL4	 43	 43	 47	 53	 44	  47	  46	 59	 58	51	50	 55</span><br><span class="line">Dynamin	ORTHOMCL5	 43	 40	 43	 44	 31	  46	  33	 79	 70	43	49	 50</span><br></pre></td></tr></table></figure>
<p>使用Orthogroups.GeneCount.tsv得到gene_families.txt，需要进行一些处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -v OFS=&quot;\t&quot; &#x27;&#123;$NF=null;print $1,$0&#125;&#x27; Orthogroups.GeneCount.tsv |sed -E -e &#x27;s/Orthogroup/desc/&#x27; -e &#x27;s/_[^\t]+//g&#x27; &gt;gene_families.txt</span><br></pre></td></tr></table></figure>
<p>这一步的主要操作是给文件加上第一列desc，除此之外就是将文件分隔符改为\t</p>
<p>值得注意的是如果不事先删除不同物种间的基因拷贝数变异特别大的基因家族，则会出现报错  </p>
<pre><code>Failed to initialize any reasonable values
</code></pre>
<p>可以使用cafe5自带的一个脚本，cafe5的tutorial目录下脚本clade_and_size_filter.py可以筛除一个或以上物种有超过100个基因拷贝的基因家族。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python clade_and_size_filter.py -s -i gene_families.txt -o gene_familie_filter.txt</span><br></pre></td></tr></table></figure>
<p>注意运行脚本时gene_families.txt需删去表头，但是CAFE的输入文件需要表头，因此后面需要加上</p>
<h3 id="2-2tree-txt"><a href="#2-2tree-txt" class="headerlink" title="2.2tree.txt"></a>2.2tree.txt</h3><p>带分化时间的，二叉的，有根的，超度量树，树的格式为newick格式，超度量树指树的最近发散序列的分支长度相等。<br>可以使用PAML生成的结果FigTree.tre转换成tree.txt文件  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -E -v &quot;NEXUS|BEGIN|END&quot; FigTree.tre|sed -E -e &quot;s/\[[^]]*\]//g&quot; -e &quot;s/[ \t]//g&quot; -e &quot;/^$/d&quot; -e &quot;s/UTREE/tree tree/&quot; &gt;tree.txt</span><br><span class="line">cat FigTree.tre | sed &#x27;s/\[[^]]\+\]//g&#x27;| awk -F &quot;=&quot; &#x27;/UTREE/&#123;print $2&#125; &#x27; &gt; input.tree.nwk</span><br><span class="line">sed -e &#x27;s/:/\n:/g&#x27; -e &#x27;s/\([),]\)/\n\1/g&#x27; input.tree.nwk | awk &#x27;&#123;if($1~/:$/)&#123;printf &quot;:&quot;100*$2&#125; else &#123;printf $0&#125;&#125;&#x27; | sed &#x27;s/\s\+//g&#x27; &gt; input.tree</span><br></pre></td></tr></table></figure>
<h2 id="3-运行"><a href="#3-运行" class="headerlink" title="3.运行"></a>3.运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cafe5 --infile gene_families.txt --tree tree.txt --cores 5 --output_prefix cafe_out </span><br><span class="line"></span><br><span class="line">--infile gene_families.txt 输入基因家族文件</span><br><span class="line">--tree tree.txt 输入树文件</span><br><span class="line">--cores 5 指定5个核运行</span><br><span class="line">--output_prefix cafe_out 输出文件名</span><br></pre></td></tr></table></figure>
<p>其他可添加参数  </p>
<ul>
<li>-p代表指定root frequency distribution为泊松分布（默认是均匀分布uniform distribution）。</li>
<li>-k 3代表使用GAMMA模型（默认是base模型）并且使用3种gamma rate（代表不同基因家族有着不同的进化速率）。-k的值需要运行多次比较likelihood并确保收敛后才知道使用哪个最好，一般来说2-5之间试一试。</li>
</ul>
<h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cafe_out/</span><br><span class="line">Base_asr.tre # 进化树格式，记录了基因数目, 显著变化节点*标</span><br><span class="line">Base_branch_probabilities.tab # 记录每个节点pvalue</span><br><span class="line">Base_change.tab # 记录每个节点增加或减少的基因数目</span><br><span class="line">Base_clade_results.txt # 每个节点收缩扩张基因家族数目统计，可用于做饼图</span><br><span class="line">Base_count.tab # 记录每个节点基因数目</span><br><span class="line">Base_family_likelihoods.txt</span><br><span class="line">Base_family_results.txt # 记录家族水平是否显著变化即p&lt;0.05</span><br><span class="line">Base_results.txt</span><br></pre></td></tr></table></figure>
<p>Base_asr.tre文件是记录信息最全的文件，开头部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#nexus</span><br><span class="line">BEGIN TREES;</span><br><span class="line">  TREE OG0000000 = ((LZ&lt;1&gt;*_3:8.21782,WX&lt;2&gt;_34:8.21782)&lt;27&gt;*_43:1.706,(JB&lt;3&gt;_69:9.62703,(SJ&lt;4&gt;_72:8.85394,(YX&lt;5&gt;*_116:7.83667,(WYZ&lt;6&gt;*_49:6.95006,(SL&lt;7&gt;_65:6.43522,(SD&lt;8&gt;_88:5.94193,((DX&lt;9&gt;*_188:4.89218,(PT&lt;10&gt;_112:4.47741,((MGY&lt;11&gt;*_144:2.19967,NNJ&lt;12&gt;*_102:2.19967)&lt;38&gt;_117:1.19645,(YJ&lt;13&gt;*_96:2.48949,(nigra&lt;14&gt;_134:0.284379,CH&lt;15&gt;_137:0.284379)&lt;40&gt;*_134:2.20511)&lt;39&gt;_113:0.906634)&lt;37&gt;_112:1.08128)&lt;36&gt;_107:0.414774)&lt;35&gt;*_105:0.614199,(MDL&lt;16&gt;*_58:4.33793,((EL&lt;17&gt;_95:1.21337,XZ&lt;18&gt;_90:1.21337)&lt;43&gt;_90:1.9202,(EZQ&lt;19&gt;*_62:1.90236,(HG&lt;20&gt;_76:1.32269,((TN&lt;21&gt;*_85:1.16139,HYM&lt;22&gt;*_66:1.16139)&lt;47&gt;_77:0.072474,(XH&lt;23&gt;_82:0.435824,(WC&lt;24&gt;_81:0.35856,JN&lt;25&gt;_80:0.35856)&lt;49&gt;_80:0.077264)&lt;48&gt;_80:0.798037)&lt;46&gt;_77:0.088832)&lt;45&gt;_77:0.579668)&lt;44&gt;_76:1.23121)&lt;42&gt;_82:1.20436)&lt;41&gt;*_83:1.16845)&lt;34&gt;*_91:0.43555)&lt;33&gt;*_86:0.493286)&lt;32&gt;_81:0.514848)&lt;31&gt;_77:0.886606)&lt;30&gt;*_74:1.01727)&lt;29&gt;*_66:0.773085)&lt;28&gt;_60:0.296801)&lt;26&gt;_58;</span><br><span class="line">  TREE OG0000005 = ((LZ&lt;1&gt;*_1:8.21782,WX&lt;2&gt;_12:8.21782)&lt;27&gt;*_18:1.706,(JB&lt;3&gt;*_41:9.62703,(SJ&lt;4&gt;*_13:8.85394,(YX&lt;5&gt;_32:7.83667,(WYZ&lt;6&gt;_49:6.95006,(SL&lt;7&gt;*_32:6.43522,(SD&lt;8&gt;_60:5.94193,((DX&lt;9&gt;*_72:4.89218,(PT&lt;10&gt;*_84:4.47741,((MGY&lt;11&gt;_63:2.19967,NNJ&lt;12&gt;*_45:2.19967)&lt;38&gt;_55:1.19645,(YJ&lt;13&gt;_60:2.48949,(nigra&lt;14&gt;_42:0.284379,CH&lt;15&gt;_44:0.284379)&lt;40&gt;*_44:2.20511)&lt;39&gt;_54:0.906634)&lt;37&gt;_56:1.08128)&lt;36&gt;_59:0.414774)&lt;35&gt;_58:0.614199,(MDL&lt;16&gt;*_45:4.33793,((EL&lt;17&gt;_73:1.21337,XZ&lt;18&gt;*_85:1.21337)&lt;43&gt;_77:1.9202,(EZQ&lt;19&gt;*_94:1.90236,(HG&lt;20&gt;*_88:1.32269,((TN&lt;21&gt;_70:1.16139,HYM&lt;22&gt;_79:1.16139)&lt;47&gt;_74:0.072474,(XH&lt;23&gt;_64:0.435824,(WC&lt;24&gt;*_48:0.35856,JN&lt;25&gt;_58:0.35856)&lt;49&gt;*_58:0.077264)&lt;48&gt;*_61:0.798037)&lt;46&gt;_74:0.088832)&lt;45&gt;_75:0.579668)&lt;44&gt;_77:1.23121)&lt;42&gt;*_71:1.20436)&lt;41&gt;_60:1.16845)&lt;34&gt;*_55:0.43555)&lt;33&gt;*_51:0.493286)&lt;32&gt;_46:0.514848)&lt;31&gt;*_43:0.886606)&lt;30&gt;*_36:1.01727)&lt;29&gt;_29:0.773085)&lt;28&gt;_27:0.296801)&lt;26&gt;_26;</span><br></pre></td></tr></table></figure>
<p>Base_asr.tre记录文件信息为TREE &lt;Family ID&gt; +树(物种名&lt;内部节点名称&gt;_基因家族数量：枝长……..以此类推)，*号表示该节点相对于最近祖先的基因家族变化非常显著，p&lt;0.05</p>
<h2 id="5-可视化"><a href="#5-可视化" class="headerlink" title="5.可视化"></a>5.可视化</h2><h3 id="5-1绘制饼图"><a href="#5-1绘制饼图" class="headerlink" title="5.1绘制饼图"></a>5.1绘制饼图</h3><p>将基因家族扩张收缩的条数用于绘制饼图，绘制过程可以使用itol网站，绘制文件是树文件，因此需要从CAFE结果中提取树文件<br>Base_asr.tre中记录了所有基因家族的树，所有的树都是一致的，只不过基因家族数不同，因此可以使用以下代码提取任意一个树即可  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;/TREE OG0000000 = /&#123;print $NF&#125;&#x27; out/Base_asr.tre |sed -r &#x27;s/_[0-9]+//g ; s/([^)])&lt;[0-9]+&gt;/\1/g ; s/\*//g&#x27; &gt;out.tree</span><br></pre></td></tr></table></figure>
<p>然后就是具体基因家族扩张收缩绘图文件获得</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">##提取cafe输出的家族总个数，用于计算基因家族有多少基因家族没有变化</span><br><span class="line">Tnum=$(grep -c &quot;OG&quot; Orthogroups.GeneCount.tsv)</span><br><span class="line">##生成用于itol绘图的dataset文件</span><br><span class="line">echo -e &quot;DATASET_PIECHART</span><br><span class="line">SEPARATOR\tTAB</span><br><span class="line">DATASET_LABEL\ttest</span><br><span class="line">FIELD_COLORS\t#339900\t#FF0033\t#0099FF</span><br><span class="line">FIELD_LABELS\tIncrease\tDecrease\tRemain</span><br><span class="line">DATA&quot; &gt; cafe_itol.txt</span><br><span class="line">##获得扩张收缩家族数</span><br><span class="line">sed -r &#x27;s/^([^&gt;]+)&lt;[0-9]+&gt;/\1/g&#x27; out/Base_clade_results.txt | awk  &#x27;!/^#/&#123; p=0.5; s=10; C=&#x27;$Tnum&#x27;-$2-$3-1; if(!/^&lt;/)&#123;p=-1&#125;; print $1 &quot;\t&quot; p &quot;\t&quot; s &quot;\t&quot; $2 &quot;\t&quot; $3 &quot;\t&quot; C &#125;&#x27; &gt;&gt; cafe_itol.txt</span><br></pre></td></tr></table></figure>
<p>itol的dataset文件表头以下信息的含义为<br>第一列绘制饼图的内部节点的名称，第二列为饼图绘制的位置，第四列为饼图的直径，第五列之后是绘制饼图的绘制数据<br>绘制时，直接拖入饼图dataset文件即可</p>
<p>除此之外，itol网站还可以添加标签注释，与上面类似，只需要写好绘图的dataset文件即可，所有文件格式均在itol最上面HELP-&gt;HELP PAGE，页面左侧Dataset type中有详细介绍与示例文件，以下展示添加文本标签的示例文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">DATASET_TEXT</span><br><span class="line"># 在文本数据集中，每个ID关联一个文本标签，可直接显示在节点分支上或树外</span><br><span class="line"># 以井号(#)开头的行是注释，解析时会被忽略</span><br><span class="line">#=================================================================#</span><br><span class="line">#                        必填设置                                 #</span><br><span class="line">#=================================================================#</span><br><span class="line"># 选择下方数据的分隔符（TAB, SPACE 或 COMMA）。此分隔符必须在全文件统一使用。</span><br><span class="line"># SEPARATOR TAB</span><br><span class="line"># SEPARATOR SPACE</span><br><span class="line">SEPARATOR COMMA  # 当前使用逗号分隔</span><br><span class="line"></span><br><span class="line"># 用于图例表的标签（后续可修改）</span><br><span class="line">DATASET_LABEL,example text dataset</span><br><span class="line"></span><br><span class="line"># 数据集颜色（后续可修改）</span><br><span class="line">COLOR,#ff0000  # 红色</span><br><span class="line"></span><br><span class="line">#=================================================================#</span><br><span class="line">#                        可选设置                                 #</span><br><span class="line">#=================================================================#</span><br><span class="line"># 所有其他可选设置可在网页界面中修改（位于&#x27;Datasets&#x27;选项卡下）</span><br><span class="line"></span><br><span class="line"># 左边距（可正可负），用于调整与下一个数据集的间距。仅影响外部文本标签</span><br><span class="line">MARGIN,0</span><br><span class="line"></span><br><span class="line"># 仅适用于外部文本标签。设为1时，即使内部节点未折叠也会显示其标签（可能导致重叠）</span><br><span class="line">SHOW_INTERNAL,0</span><br><span class="line"></span><br><span class="line"># 所有标签旋转指定角度</span><br><span class="line">ALL_LABELS_ROTATION,0</span><br><span class="line"></span><br><span class="line"># 默认内部标签在分支上方。设为1时，标签显示在分支下方</span><br><span class="line">LABELS_BELOW,1</span><br><span class="line"></span><br><span class="line"># 垂直方向移动标签的像素值（可正可负）</span><br><span class="line">VERTICAL_SHIFT,0</span><br><span class="line"></span><br><span class="line"># 设为1时，树形旋转不会影响单个标签的旋转</span><br><span class="line">STRAIGHT_LABELS,0</span><br><span class="line"></span><br><span class="line"># 仅适用于外部标签。设为1时，标签将沿树对齐（圆形模式）或垂直显示（常规模式），忽略所有旋转参数</span><br><span class="line">ALIGN_TO_TREE,0</span><br><span class="line"></span><br><span class="line"># 字体大小因子：外部标签默认字体大小略小于叶节点间距，此值可缩放（&lt;1减小，&gt;1增大）</span><br><span class="line">SIZE_FACTOR,1</span><br><span class="line"></span><br><span class="line"># 外部标签额外水平偏移（适用于无根模式调整标签位置）</span><br><span class="line">EXTERNAL_LABEL_SHIFT,0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 是否在外部标签列上方显示数据集标签（注释状态）</span><br><span class="line">#SHOW_LABELS 1</span><br><span class="line"></span><br><span class="line"># 数据集标签大小因子（注释状态）</span><br><span class="line">#LABEL_SIZE_FACTOR 1</span><br><span class="line"></span><br><span class="line"># 数据集标签旋转（注释状态）</span><br><span class="line">#LABEL_ROTATION 0</span><br><span class="line"></span><br><span class="line"># 数据集标签像素偏移（注释状态）</span><br><span class="line">#LABEL_SHIFT 0</span><br><span class="line"></span><br><span class="line"># 数据集标签与树对齐（仅圆形模式有效，注释状态）</span><br><span class="line">#LABEL_ALIGN_TO_TREE,0</span><br><span class="line"></span><br><span class="line"># 内部节点可通过ID直接指定，或用iTOL帮助文档描述的&#x27;最后共同祖先&#x27;方法</span><br><span class="line">#=================================================================#</span><br><span class="line">#                 数据部分（&quot;DATA&quot;关键字后开始）                  #</span><br><span class="line">#=================================================================#</span><br><span class="line"># 每个节点可包含以下字段：</span><br><span class="line"># ID,标签文本,位置,颜色,样式,大小因子,旋转角度</span><br><span class="line"></span><br><span class="line"># 位置参数说明：</span><br><span class="line">#  -1 = 外部标签</span><br><span class="line">#  0-1 = 内部标签（0:分支起点, 0.5:中点, 1:终点）</span><br><span class="line"># 样式可选：&#x27;normal&#x27;,&#x27;bold&#x27;,&#x27;italic&#x27;,&#x27;bold-italic&#x27;</span><br><span class="line"># 大小因子将乘以标准字体大小</span><br><span class="line"></span><br><span class="line">DATA</span><br><span class="line"># 示例：</span><br><span class="line"></span><br><span class="line"># 节点9598将显示红色粗体外部标签&quot;Pan troglodytes&quot;，字体大小为标准2倍</span><br><span class="line">#9598,Pan troglodytes,-1,#ff0000,bold,2,0</span><br><span class="line"></span><br><span class="line"># 节点9606将显示多样式混合外部标签</span><br><span class="line">#9606,&lt;bi color=&#x27;#006600&#x27;&gt;Homo &lt;/bi&gt;&lt;i&gt;sapiens&lt;/i&gt;&lt;sup size=&#x27;0.5&#x27; color=&#x27;#999999&#x27;&gt;citation&lt;/sup&gt;,-1,#000000,normal,1,0</span><br><span class="line"></span><br><span class="line"># 节点4530将显示蓝色粗斜体内部标签&quot;Oryza sativa&quot;，位于分支起点</span><br><span class="line">#4530,Oryza sativa,0,#0000ff,bold-italic,1,0</span><br><span class="line"></span><br><span class="line">其实与上面饼图文件一样，表头信息加后面的数据</span><br><span class="line">echo -e &quot;DATASET_TEXT</span><br><span class="line">SEPARATOR	TAB</span><br><span class="line">DATASET_LABEL	TEST</span><br><span class="line">COLOR	#ff0000</span><br><span class="line">DATA&quot; &gt; cafe.txt</span><br><span class="line">sed -r &#x27;s/^([^&gt;]+)&lt;[0-9]+&gt;/\1/g&#x27; |awk &#x27;&#123;print $1&quot;\t+&quot;$2&quot;/-&quot;$3&quot;\t0.5\t#ff0000\tnormal\t1\t0&quot;&#125;&#x27; &gt;&gt; cafe.txt</span><br><span class="line">sed -i &#x27;/&lt;[0-9]\+&gt;/d&#x27; cafe.txt</span><br></pre></td></tr></table></figure>
<p>配置完成之后一样，拖入网站即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/19/%E5%88%86%E5%8C%96%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Plank">
      <meta itemprop="description" content="白马？定叫他有来无回！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeFun blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/19/%E5%88%86%E5%8C%96%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-19 15:53:23 / 修改时间：15:27:50" itemprop="dateCreated datePublished" datetime="2025-05-19T15:53:23+08:00">2025-05-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="分化时间计算"><a href="#分化时间计算" class="headerlink" title="分化时间计算"></a>分化时间计算</h1><pre><code>分化时间或称分歧时间估计，依据的是分子钟假说，即氨基酸或核苷酸替代速率在进化过程中随时间或进化谱系近似地保持恒定，以某几个特定类群的化石时间作为校正，然后通过基因序列间的分歧程度以及分子钟来估算物种间的分歧时间，同时估算系统发育树上其它节点的发生时间，从而推断相关类群的起源和不同类群的分歧时间。目前，采用依据BI树和ML树估计物种分歧时间的程序很多，例如R8S、MCMCTREE、MULTIDIVTIME、BEAST、MEGA等，不同软件通过不同的策略将化石时间信息整合到一个系统发育树中，从而计算得到Divergence time Tree。  
</code></pre>
<p>分子钟假说成立的条件DNA或者蛋白质序列的替代速率是恒定的。20世纪80年代以来，随着DNA序列数据快速积累，大量的证据表明：在长期进化过程中，很多类群的绝大多数基因或蛋白质的序列替换速率根本不符合分子钟假说。对于蛋白质序列，在物种适应辐射过程中，其进化速度可能会大大加快。因此，以蛋白质为基础的恒定进化速率并非理想的分子钟；对于核酸分子，不同基因的分子钟速率不同，但是我们可以认为相同物种某一片段的基因或者蛋白质的替代速率是一定的，在此基础上可以将分子钟模型分为全局分子钟（序列间的期望距离随分歧时间线性增加），局部分子钟模型（不同分支的进化速率不同）<br>在速率恒定的假设下，遗传距离是时间的线性函数，为了将遗传距离转化为分歧时间，至少需要一个能够提供时间信息的标定点（calibration point）。常用的校准信息可以分为：(1)已知的碱基替代速率；(2)化石校准点；(3)生物地理事件校准点；(4)二次校准点<br>本篇教程主要参考：<a target="_blank" rel="noopener" href="https://yanzhongsino.github.io/2021/03/25/bioinfo_phylogeny_caculate.divergence.time/">https://yanzhongsino.github.io/2021/03/25/bioinfo_phylogeny_caculate.divergence.time/</a>  </p>
<h2 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1.安装软件"></a>1.安装软件</h2><p>PAML (Phylogenetic Analysis by Maximum Likelihood)，网址：<a target="_blank" rel="noopener" href="https://github.com/abacus-gene/paml">https://github.com/abacus-gene/paml</a><br>官方安装教程网址：<a target="_blank" rel="noopener" href="https://github.com/abacus-gene/paml/wiki/Installation#exporting-paths-linux">https://github.com/abacus-gene/paml/wiki/Installation#exporting-paths-linux</a> ，因此不过多介绍安装流程  </p>
<h2 id="2-准备文件"><a href="#2-准备文件" class="headerlink" title="2.准备文件"></a>2.准备文件</h2><p>多序列比对文件，phylip格式<br>有化石时间标定的进化树（有根树）<br>mcmctree配置文件</p>
<h3 id="2-1检查进化树的结构是否有问题"><a href="#2-1检查进化树的结构是否有问题" class="headerlink" title="2.1检查进化树的结构是否有问题"></a>2.1检查进化树的结构是否有问题</h3><p>ncbi-&gt;taxonomy-&gt;taxonomy common tree（按照物种分类展示的树结构），输入物种的拉丁名，可以看物种的大致进化关系</p>
<h3 id="2-2寻找相应物种的化石时间"><a href="#2-2寻找相应物种的化石时间" class="headerlink" title="2.2寻找相应物种的化石时间"></a>2.2寻找相应物种的化石时间</h3><p>在线网站：<a target="_blank" rel="noopener" href="https://timetree.org/home">https://timetree.org/home</a> ，网站主要记录物种的进化时间和进化关系，会定期更新，有三种搜索模式，1）输入两个物种名称，即可计算得到二者的进化时间，2）提供物种名称，给出该物种的进化事件，3）给出一组物种，他来标定化石时间，一般使用第三种<br>注意查看引用文件，了解使用的是分子时间还是化石时间</p>
<p>展示结果：<br><strong>1）直接输入</strong><br>左侧展示所有研究的分化时间可视化，横坐标文字部分是地质年代，数字为地质年代，曲线从左往右依次是光照，二氧化碳含量，氧含量，陨石撞击事件的陨石坑大小<br>右侧会给出Median Time：XXXMYA（百万年）、大致区间以及所有相关研究给出的大致时间的正态拟合<br>下面表格给出的是相关文献以及对应事件<br><strong>2）提供物种</strong><br>左侧上同<br>右侧展示出物种的进化历史，界门纲目科属种出现的时间<br><strong>3）上传物种名称</strong><br>先显示进化关系，空心的点表示研究相对较少的时间节点，实心点表示研究较多的时间节点，*号表示物种名称被替换成收录名称<br>其他大致一样不过多介绍  </p>
<p>展示出化石时间后，有两种使用方式：<br>1.直接下载相应的树文件，作为有化石时间标定的树文件（左侧最下角，To Newick File）<br>2.copy想要的化石时间，加到自己的树文件中，使用的是RANGE TIME  </p>
<p>一般使用第二种，将之前建树所得的newick树文件中的枝长自展值删去，添加上化石时间范围以及物种数和树的数量（中间用空格隔开），添加之后如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">25 1</span><br><span class="line">((LZ,WX),(JB,(SJ,(YX,(WYZ,(SL,(SD,((DX,(PT,((MGY,NNJ),(YJ,(nigra,CH)))),(MDL,((EL,XZ)&#x27;&gt;1.14&lt;1.30&#x27;,(EZQ,(HGM,((TN,HYM),(XH,(WC,JN))))))))))))))));</span><br><span class="line">((SL,(WYZ,(YX,(SJ,((WX,LZ),JB))))),((((XZ,EL)&#x27;&gt;1.14&lt;1.30&#x27;,(EZQ,(HG,((HYM,TN),(XH,(JN,WC))))))&#x27;&gt;1.3&lt;1.42&#x27;,MDL),(DX,(PT,((NNJ,MGY),(YJ,(CH,nigra)))))),SD); </span><br></pre></td></tr></table></figure>
<p>注意：1代表100MYA，以及之前建树是在ITOL中定的根，一定得是有根树<br>删去自展值可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/:[^,)(]\+//&#x27; Speciestree.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-3获得phylip格式多序列比对文件"><a href="#2-3获得phylip格式多序列比对文件" class="headerlink" title="2.3获得phylip格式多序列比对文件"></a>2.3获得phylip格式多序列比对文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat SpeciesTreeAlignment.fa |tr &#x27;\n&#x27; &#x27;\t&#x27;|sed &#x27;s/&gt;/\n/g&#x27; |sed &#x27;s/\t/      /&#x27;|sed &#x27;s/\t//g&#x27;| awk &#x27;NF &gt; 0&#x27; &gt; supergene.phy.tmp</span><br><span class="line">awk &#x27;&#123;print &quot;  &quot;NR&quot;  &quot;length($2)&#125;&#x27;  supergene.phy.tmp|tail -n 1 | cat -  supergene.phy.tmp &gt;  supergene.phy</span><br></pre></td></tr></table></figure>
<ul>
<li>cat SpeciesTreeAlignment.fa |tr ‘\n’ ‘\t’ (将换行符替换为制表符) |</li>
<li>sed ‘s&#x2F;&gt;&#x2F;\n&#x2F;g’ (将每个序列名前面的&gt;符号替换为换行符) |</li>
<li>sed ‘s&#x2F;\t&#x2F;      &#x2F;‘ (将每行第一个的制表符替换为多个空格) |</li>
<li>sed ‘s&#x2F;\t&#x2F;&#x2F;g’ (删除剩余的制表符,使序列连成一条线) |</li>
<li>awk ‘NF &gt; 0’ (删除空行)&gt; supergene.phy.tmp (临时保存)</li>
<li>awk ‘{print “  “NR”  “length($2)}’  supergene.phy.tmp (计算序列长度)|</li>
<li>tail -n 1 (返回最后一行,包括了行数与序列长度) |</li>
<li>cat -  supergene.phy.tmp (-为上一管道数据) &gt;  supergene.phy(最终文件)（代码来源：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9f46341d2906">https://www.jianshu.com/p/9f46341d2906</a> ）</li>
</ul>
<p>或者使用软件fast2phy(<a target="_blank" rel="noopener" href="https://github.com/davidmnoriega/fast2phy">https://github.com/davidmnoriega/fast2phy</a> )<br>亦或者使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trimal -in SpeciesTreeAlignment.fa -out supergene.phy -phylip_paml</span><br></pre></td></tr></table></figure>

<p>如果有多个区域的序列，比如exon和intron，LSC、SSC和IR，不同的基因，密码子的第一二三位，需要不同的模型分开估算，那可以把各自区域分别align之后制作多个phy文件，再合并到一起，用空行隔开，组成input.phy文件。（此时mcmctree.ctl的ndata值为区域的个数）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#OG.length包含两列，一列OGID，一列比对后序列长度</span><br><span class="line">cat ./OG.length | while read line</span><br><span class="line">do</span><br><span class="line">        sample_id=$(echo $line |awk &#x27;&#123;print $1&#125;&#x27;) #获取OG.ID</span><br><span class="line">        sample_a=$(echo $line |awk &#x27;&#123;print $2&#125;&#x27;) #获取序列长度</span><br><span class="line">        sed &quot;s/_.*//g&quot; ../singlegenetree/$&#123;sample_id&#125;/$&#123;sample_id&#125;.mafft.pep|seqkit seq -w 0|sed -E &quot;:a;N;s/\n/ /g;ta&quot; |sed &quot;s/ &gt;/\n/g&quot; |sed &quot;s/&gt;//g&quot;|sed &quot;s/ /  /g&quot;|sed &quot;1i\5  $&#123;sample_a&#125;&quot; |sed &#x27;1i\ &#x27; &gt; ./phy/$&#123;sample_id&#125;.phy #把上一步获取的$&#123;sample_id&#125;.mafft.pep改为phylip格式，并在首行添加空格行（为了合并后每个OG用空行隔开）</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line">cat ./phy/*phy &gt;input.phy #合并所有phy文件为一个.phy</span><br></pre></td></tr></table></figure>
<p>（代码来源：<a target="_blank" rel="noopener" href="https://yanzhongsino.github.io/2021/03/25/bioinfo_phylogeny_caculate.divergence.time/">https://yanzhongsino.github.io/2021/03/25/bioinfo_phylogeny_caculate.divergence.time/</a> ）</p>
<h2 id="2-4mcmctree配置文件"><a href="#2-4mcmctree配置文件" class="headerlink" title="2.4mcmctree配置文件"></a>2.4mcmctree配置文件</h2><p>mcmctree配置文件为mcmctree.ctl，具体参数及介绍如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">seed = -1 *设置随机数作为seed，-1代表使用系统当前时间作为随机数</span><br><span class="line">seqfile = supergene.phy *输入多序列比对文件</span><br><span class="line">treefile =MCMTREE.tree *带校准点（化石时间）的有根树文件</span><br><span class="line">outfile = mcmc.out *输出文件</span><br><span class="line">mcmcfile = mcmc.txt *输出的mcmc信息文件，可用Tracer软件查看</span><br><span class="line"></span><br><span class="line">seqtype = 0  * 设置多序列比对数据类型；0：核酸数据；1：密码子比对数据；2：氨基酸数据；</span><br><span class="line">usedata = 3</span><br><span class="line">* 是否利用多序列比对数据；</span><br><span class="line">* 0: no data不使用，不会进行likelihood估算，会快速得到mcmc树，但分歧时间不可用; </span><br><span class="line">* 1:seq like，使用多序列比对数据进行likelihood估算，正常进行mcmc; usedata=1时model无法选择；</span><br><span class="line">* 2:normal 进行正常的approximation likelihood分析，不读取多序列比对数据，直接读取当前目录的in.BV文件，in.BV是由usedata = 3时生成的out.BV重命名得来；此外，由于程序BUG，当设置usedata = 2时，一定要在改行参数后加 *，否则程序报错 Error: file name empty..；</span><br><span class="line">* 3：程序利用多序列比对数据调用baseml/codeml命令对数据进行分析，生成out.BV文件。由于mcmctree调用baseml/codeml进行估算的参数设置可能不太好（特别时对蛋白序列进行估算时），推荐自己修改软件自动生成的baseml/codeml配置文件，然后再手动运行baseml/codeml命令，再整合其结果文件为out.BV文件。</span><br><span class="line"></span><br><span class="line">ndata = 1    * 输入的多序列比对的数据区域的数量；</span><br><span class="line">clock = 2    * 设置分子钟算法，1: global clock，表示所有分支进化速率一致; 2: independent rates，各分支的进化速率独立且进化速率的对数log(r)符合正态分布; 3，correlated rates方法，和方法2类似，但是log(r)的方差和时间t相关。</span><br><span class="line">*       TipDate = 1 100  *当外部节点由取样时间时使用该参数进行设置，同时该参数也设置了时间单位。具体数据示例请见examples/TipData文件夹。</span><br><span class="line">RootAge = &lt;10  * constraint on root age, used if no fossil for root.设置root节点的分歧时间，一般设置一个最大值。</span><br><span class="line"></span><br><span class="line">model = 0    * models for DNA:</span><br><span class="line">                        * 0:JC69, 1:K80, 2:F81, 3:F84, 4:HKY85；*设置碱基替换模型；当设置usedata = 1时，model不能使用超过4的模型，所以usedata = 1时用model = 4</span><br><span class="line">                      * models for codons:</span><br><span class="line">                        * 0:one 恒定速率模型, 1:b 中性模型, 2:2 or more dN/dS ratios for branches 选择模型。</span><br><span class="line">                      * models for AAs or codon-translated AAs:</span><br><span class="line">			* 0：Poisson 模型</span><br><span class="line">			* 1：Proportional 模型</span><br><span class="line">			*2：经验模型</span><br><span class="line">			*3：经验模型 + F</span><br><span class="line">			*6：基于密码子模型</span><br><span class="line">			*8：REVaa_0 模型</span><br><span class="line">			*9：REVaa (nr=189) 模型</span><br><span class="line">alpha = 0.5   * alpha for gamma rates at sites；*核酸序列中不同位点，其进化速率不一致，其变异速率服从GAMMA分布。一般设置GAMMA分布的alpha值为0.5。若该参数值设置为0，则表示所有位点的进化速率一致。此外，当userdata = 2时，alpha、ncatG、alpha_gamma、kappa_gamma这4个GAMMA参数无效。因为userdata = 2时，不会利用到多序列比对的数据。model=4时一般设为0.5，否则一般设为0</span><br><span class="line">ncatG = 5    * No. categories in discrete gamma；设置离散型GAMMA分布的categories值。</span><br><span class="line"></span><br><span class="line">cleandata = 0    * remove sites with ambiguity data (1:yes, 0:no)?是否去除gap</span><br><span class="line"></span><br><span class="line">BDparas = 1 1 0.1   * birth, death, sampling；*设置出生率、死亡率和取样比例。若输入有根树文件中的时间单位发生改变，则需要相应修改出生率和死亡率的值。例如，时间单位由100Myr变换为1Myr，则要设置成&quot;.01 .01 0.1&quot;。</span><br><span class="line">kappa_gamma = 6 2      * gamma prior for kappa；设置kappa（转换/颠换比率）的GAMMA分布参数。</span><br><span class="line">alpha_gamma = 1 1      * gamma prior for alpha；设置GAMMA形状参数alpha的GAMMA分布参数。</span><br><span class="line"></span><br><span class="line">rgene_gamma = 2 20 1   * gamma prior for rate for genes；设置序列中所所有位点平均[碱基/密码子/氨基酸]替换率的Dirichlet-GAMMA分布参数：alpha=2、beta=20、初始平均替换率为每100million年（取决于输入有根树文件中的时间单位）1个替换。若时间单位由100Myr变换为1Myr，则要设置成&quot;2 2000 1&quot;。总体上的平均进化速率为：2 / 20 = 0.1 个替换 / 每100Myr，即每个位点每年的替换数为 1e-9。</span><br><span class="line">sigma2_gamma = 1 10 1    * gamma prior for sigma^2     (for clock=2 or 3)；设置所有位点进化速率取对数后方差（sigma的平方）的Dirichlet-GAMMA分布参数：alpha=1、beta=10、初始方差值为1。当clock参数值为1时，表示使用全局的进化速率，各分枝的进化速率没有差异，即方差为0，该参数无效；当clock参数值为2时，若修改了时间单位，该参数值不需要改变；当clock参数值为3时，若修改了时间单位，该参数值需要改变。</span><br><span class="line"></span><br><span class="line">finetune = 1: .1 .1 .1 .1 .1 .1  * times, rates, mixing, paras, RateParas；冒号前的值设置是否自动进行finetune，一般设置成1，然程序自动进行优化分析；冒号后面设置各个参数的步进值：times, musigma2, rates, mixing, paras, FossilErr。由于有了自动设置，该参数不像以前版本那么重要了，可能以后会取消该参数。</span><br><span class="line"></span><br><span class="line">print = 1  *设置打印mcmc的取样信息：0，不打印mcmc结果；1，打印除了分支进化速率的其它信息（各内部节点分歧时间、平均进化速率、sigma2值）；2，打印所有信息。 </span><br><span class="line">burnin = 1000000  *将前1000000次迭代burnin后，再进行取样（即打印出该次迭代估算的结果信息，各内部节点分歧时间、平均进化速率、sigma2值和各分支进化速率等）。</span><br><span class="line">sampfreq = 10  *每10次迭代则取样一次</span><br><span class="line">nsample = 500000  *当取样次数达到该次数时，则取样结束，同时结束程序。</span><br><span class="line"></span><br><span class="line">*** Note: Make your window wider (100 columns) when running this program.</span><br></pre></td></tr></table></figure>

<h2 id="3-运行"><a href="#3-运行" class="headerlink" title="3.运行"></a>3.运行</h2><p>完成后运行<br>mcmctree mcmctree.ctl</p>
<h2 id="4-其他方法"><a href="#4-其他方法" class="headerlink" title="4.其他方法"></a>4.其他方法</h2><h3 id="4-1氨基酸序列计算分化时间"><a href="#4-1氨基酸序列计算分化时间" class="headerlink" title="4.1氨基酸序列计算分化时间"></a>4.1氨基酸序列计算分化时间</h3><p>一般不建议使用氨基酸序列去计算分化时间，因为一般需要计算氨基酸替换速率，并选择相应的模型，而使用核酸序列相对简单，但是如果想要直接使用之前Orthofinder的结果，也就是氨基酸序列进行分化时间的计算，则需要进行一些处理  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#按照上面的处理之后先计算氨基酸替换速率，修改tmp0001.ctl的内容</span><br><span class="line">cp tmp0001.ctl codeml.ctl</span><br><span class="line">#添加参数，增加gamma分布的先验数据</span><br><span class="line">echo &quot;clock =1&quot; &gt;&gt;codeml.ctl</span><br><span class="line"></span><br><span class="line">#然后修改一些参数</span><br><span class="line">model = 2 * model=0使用的是简单的一致模型计算氨基酸替换速率，一般建议使用2，使用WAG模型进行计算</span><br><span class="line">aaRatefile = /home/walnut168/mnt/wf/program/paml-4.10.7/dat/wag.dat * paml目录下的文件一般在paml/dat/wag.dat</span><br></pre></td></tr></table></figure>
<p>修改树文件<br>将tmp0001.trees文件改为有根树，并添加上化石标定时间，需要添加具体时间，一般取范围的中间数就行<br>我的原文件为  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"></span><br><span class="line">(LZ, WX, (JB, (SJ, (YX, (WYZ, (SL, (SD, ((DX, (PT, ((MGY, NNJ), (YJ, (nigra, CH))))), (MDL, ((EL, XZ), (EZQ, (HG, ((TN, HYM), (XH, (WC, JN)))))))))))))));</span><br></pre></td></tr></table></figure>
<p>修改后为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1</span><br><span class="line"></span><br><span class="line">((LZ, WX), (JB, (SJ, (YX, (WYZ, (SL, (SD, ((DX, (PT, ((MGY, NNJ), (YJ, (nigra, CH))))), (MDL, ((EL, XZ)&#x27;@1.22&#x27;, (EZQ, (HG, ((TN, HYM), (XH, (WC, JN)))))))))))))));</span><br></pre></td></tr></table></figure>
<p>修改完成后运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeml codeml.ctl</span><br></pre></td></tr></table></figure>
<p>就算完成查看tmp0001.out，替换速率在“Substitution rate is per time unit” 下一行<br>完成后修改mcmtree.ctl文件中的rgene_gamma &#x3D; 2 20，根据氨基酸替换速率修改，例如我的氨基酸替换速率为0.31，则大致修改为rgene_gamma &#x3D; 2 6<br>计算完成之后重新运行mcmctree mcmctree.ctl，重新生成out.BV文件<br>后续操作等于重新进行一次分化时间的计算，最后获得目标文件  </p>
<p>注意，运行时，程序运行日志中有进度，5%-100%后面第一列数字为模型接受程度，一般30%左右较好，最大波动为15%-70%，如果超过，最好修改burnin参数，并适当增加迭代次数等等，第二列为预估的分化时间，正常情况下应该是不断稳定下来，如果靠近100%处还波动较大，应该增加迭代次数，增加nsample，增加sampfreq  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 5% 0.42 0.29 0.45 0.40 0.25  9.662 7.289 9.250 8.390 7.561 6.124 - 0.067 0.902 -23.42  0:02</span><br><span class="line"> 10% 0.38 0.30 0.36 0.41 0.24  9.856 7.443 9.520 8.836 7.780 6.542 - 0.064 0.831 -23.58  0:03</span><br><span class="line"> 15% 0.40 0.30 0.39 0.41 0.19  9.811 7.373 9.498 8.704 7.693 6.664 - 0.063 0.812 -23.57  0:03</span><br><span class="line"> 20% 0.40 0.30 0.40 0.41 0.17  9.807 7.439 9.465 8.616 7.630 6.722 - 0.063 0.786 -23.50  0:04</span><br><span class="line"> 25% 0.38 0.29 0.40 0.40 0.15  9.754 7.513 9.436 8.632 7.685 6.842 - 0.063 0.753 -23.49  0:05</span><br><span class="line"> 30% 0.38 0.30 0.40 0.39 0.15  9.778 7.412 9.467 8.672 7.747 6.909 - 0.063 0.722 -23.49  0:05</span><br><span class="line"> 35% 0.37 0.30 0.39 0.39 0.16  9.800 7.532 9.493 8.722 7.812 6.939 - 0.064 0.696 -23.53  0:06</span><br><span class="line"> 40% 0.37 0.30 0.39 0.39 0.16  9.835 7.668 9.543 8.770 7.866 6.919 - 0.064 0.677 -23.53  0:06</span><br><span class="line"> 45% 0.35 0.29 0.41 0.41 0.16  9.853 7.787 9.546 8.745 7.809 6.883 - 0.064 0.659 -23.49  0:07</span><br><span class="line"> 50% 0.34 0.29 0.40 0.42 0.16  9.811 7.843 9.483 8.703 7.756 6.855 - 0.064 0.644 -23.51  0:08</span><br><span class="line"> 55% 0.34 0.29 0.40 0.41 0.16  9.800 7.875 9.478 8.706 7.783 6.884 - 0.065 0.633 -23.51  0:08</span><br><span class="line"> 60% 0.33 0.29 0.40 0.41 0.16  9.829 7.960 9.509 8.740 7.808 6.918 - 0.064 0.621 -23.52  0:09</span><br><span class="line"> 65% 0.33 0.29 0.40 0.42 0.15  9.843 8.032 9.526 8.760 7.800 6.944 - 0.064 0.614 -23.52  0:09</span><br><span class="line"> 70% 0.33 0.28 0.40 0.42 0.15  9.852 8.055 9.540 8.775 7.824 6.978 - 0.064 0.609 -23.52  0:10</span><br><span class="line"> 75% 0.32 0.28 0.40 0.42 0.15  9.866 8.113 9.560 8.789 7.842 6.991 - 0.064 0.604 -23.53  0:10</span><br><span class="line"> 80% 0.32 0.28 0.41 0.42 0.15  9.886 8.172 9.576 8.803 7.832 6.993 - 0.064 0.596 -23.54  0:11</span><br><span class="line"> 85% 0.31 0.28 0.40 0.43 0.15  9.891 8.207 9.587 8.825 7.832 6.981 - 0.064 0.586 -23.54  0:12</span><br><span class="line"> 90% 0.31 0.28 0.40 0.43 0.16  9.907 8.214 9.609 8.849 7.829 6.972 - 0.064 0.580 -23.55  0:12</span><br><span class="line"> 95% 0.32 0.28 0.40 0.43 0.16  9.919 8.234 9.621 8.856 7.843 6.968 - 0.064 0.572 -23.56  0:13</span><br><span class="line">100% 0.32 0.28 0.41 0.43 0.16  9.924 8.218 9.627 8.854 7.837 6.950 - 0.064 0.565 -23.55  0:13</span><br></pre></td></tr></table></figure>


<p>除此之外还需要观察mcmc.out文件最后部分，观察t_n部分，该部分为内部节点的分化时间，观察一下是否波动不大  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Posterior mean (95% Equal-tail CI) (95% HPD CI) HPD-CI-width</span><br><span class="line"></span><br><span class="line">t_n26          9.7170 ( 8.0432, 10.8710) ( 8.0329, 10.8514)  2.8185 (Jnode 48)</span><br><span class="line">t_n27          8.8041 ( 6.8167, 10.2398) ( 6.8624, 10.2803)  3.4178 (Jnode 47)</span><br><span class="line">t_n28          9.4250 ( 7.7433, 10.6173) ( 7.8992, 10.7086)  2.8094 (Jnode 46)</span><br><span class="line">t_n29          8.6206 ( 6.9800,  9.8600) ( 7.1669, 10.0149)  2.8481 (Jnode 45)</span><br><span class="line">t_n30          7.3818 ( 5.9074,  8.4911) ( 5.9742,  8.5341)  2.5599 (Jnode 44)</span><br><span class="line">t_n31          6.1850 ( 4.7974,  7.4212) ( 4.8173,  7.4297)  2.6125 (Jnode 43)</span><br><span class="line">t_n32          5.6159 ( 4.2569,  6.9734) ( 4.2563,  6.9714)  2.7152 (Jnode 42)</span><br><span class="line">t_n33          4.8949 ( 3.7075,  6.2810) ( 3.5774,  6.0312)  2.4538 (Jnode 41)</span><br><span class="line">t_n34          4.3230 ( 3.1748,  5.2996) ( 3.2144,  5.3294)  2.1149 (Jnode 40)</span><br><span class="line">t_n35          3.1460 ( 2.3840,  3.8388) ( 2.3812,  3.8352)  1.4540 (Jnode 39)</span><br><span class="line">t_n36          2.5618 ( 1.9859,  3.1193) ( 1.9480,  3.0724)  1.1243 (Jnode 38)</span><br><span class="line">t_n37          2.1956 ( 1.6387,  2.6295) ( 1.6494,  2.6355)  0.9861 (Jnode 37)</span><br><span class="line">t_n38          1.6816 ( 0.9820,  2.2494) ( 1.0505,  2.2811)  1.2306 (Jnode 36)</span><br><span class="line">t_n39          1.7495 ( 1.2646,  2.2873) ( 1.2470,  2.2652)  1.0182 (Jnode 35)</span><br><span class="line">t_n40          0.1633 ( 0.0571,  0.3442) ( 0.0426,  0.2922)  0.2496 (Jnode 34)</span><br><span class="line">t_n41          3.7507 ( 2.8133,  4.5681) ( 2.8132,  4.5679)  1.7547 (Jnode 33)</span><br><span class="line">t_n42          2.9491 ( 2.2476,  3.6595) ( 2.2476,  3.6593)  1.4117 (Jnode 32)</span><br><span class="line">t_n43          1.1929 ( 1.1358,  1.2913) ( 1.1322,  1.2855)  0.1533 (Jnode 31)</span><br><span class="line">t_n44          0.7227 ( 0.4832,  1.0478) ( 0.4510,  0.9966)  0.5456 (Jnode 30)</span><br><span class="line">t_n45          0.3438 ( 0.2135,  0.4484) ( 0.2025,  0.4341)  0.2315 (Jnode 29)</span><br><span class="line">t_n46          0.3157 ( 0.1971,  0.4061) ( 0.1916,  0.3997)  0.2082 (Jnode 28)</span><br><span class="line">t_n47          0.2863 ( 0.1536,  0.3715) ( 0.1659,  0.3797)  0.2139 (Jnode 27)</span><br><span class="line">t_n48          0.1475 ( 0.0932,  0.2344) ( 0.0897,  0.2286)  0.1389 (Jnode 26)</span><br><span class="line">t_n49          0.1210 ( 0.0707,  0.2043) ( 0.0671,  0.1954)  0.1283 (Jnode 25)</span><br><span class="line">mu             0.0954 ( 0.0759,  0.1246) ( 0.0744,  0.1216)  0.0472</span><br><span class="line">sigma2         0.2907 ( 0.1821,  0.4506) ( 0.1740,  0.4368)  0.2627</span><br><span class="line">lnL          -23.5714 (-34.0770, -15.1300) (-33.1800, -14.4370) 18.7430</span><br></pre></td></tr></table></figure>
<p>一般近似似然法计算就是会有较大的误差，所以还是推荐使用usedata &#x3D; 1</p>
<h2 id="4-2-4D位点计算分化时间"><a href="#4-2-4D位点计算分化时间" class="headerlink" title="4.2 4D位点计算分化时间"></a>4.2 4D位点计算分化时间</h2><p>什么是4D位点？一个遗传密码子通常由三个核苷酸构成，从左到右依次为第一个位点、第二个位点、第三个位点。如果密码子的某个位点上无论是哪种核苷酸，均编码同样的氨基酸，则称这个位点为 4 倍简并位点，这个位点一般是密码子的第三位。4DTV( four-fold synonymous (degenerative) third-codon transversion) 表示4D位点（fourfold degenerate site）上发生颠换（嘌呤突变为嘧啶或者嘧啶突变为嘌呤）的位点替换率。</p>
<p>使用单拷贝基因家族的4D位点计算分化时间，则还需要准备以下文件</p>
<ul>
<li>1）CDS文件</li>
<li>2）单拷贝基因家族列表<br>Orthogroups_SingleCopyOrthologues.txt（基因家族ID）</li>
<li>3）单拷贝基因家族的序列</li>
<li>4）基因家族统计列表<br>Orthogroups.tsv（基因ID）</li>
</ul>
<p>首先根据单拷贝基因家族列表提取出基因id  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less Orthogroups_SingleCopyOrthologues.txt | while read aa ;do grep $aa Orthogroups.tsv ;done &gt; id.txt</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;if(NR==FNR)&#123;A[$1]=1&#125;else&#123; if($1 in A || FNR==1)&#123;print $0&#125;&#125; &#125;&#x27; \</span><br><span class="line">Orthogroups_SingleCopyOrthologues.txt Orthogroups.tsv \</span><br><span class="line">&gt; single_copy.txt</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;if(NR==1)&#123;f=NF&#125;; if( $0 !~ /,/ &amp;&amp; NF==f )&#123;print $0&#125;&#125;&#x27; Orthogroups.tsv &gt; single_copy.txt</span><br></pre></td></tr></table></figure>
<p>在每个ID前加上物种前缀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;if(NR==1)&#123; n=split($0,A, &quot;\t&quot;)&#125; else &#123; for(i=2; i&lt;= n; i++)&#123; \</span><br><span class="line">printf A[i]&quot;_&quot;$i&quot;\t&quot; &#125;; printf &quot;\n&quot; &#125; &#125;&#x27; single_copy.txt | \</span><br><span class="line">sed &#x27;s/\s\+$//&#x27; &gt; single_copy.txt.change</span><br></pre></td></tr></table></figure>
<p>给每一个cds序列添加上物种标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for i in cds/*.fa;do</span><br><span class="line">base=$(basename &quot;$i&quot; .fa);</span><br><span class="line">sed &quot;s/^&gt;/&gt;$&#123;base&#125;_/&quot; &quot;$i&quot; &gt;&quot;$base.fa.change&quot;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>protein序列进行类似操作</p>
<p>合并cds和protein文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat changecds/*.fa.change &gt; all.cds.fa</span><br><span class="line">cat changepep/*.fa.change &gt;all.pep.fa</span><br></pre></td></tr></table></figure>

<p>使用ParaAT（<a target="_blank" rel="noopener" href="https://github.com/wonaya/ParaAT">https://github.com/wonaya/ParaAT</a> ）提取相应的cds文件  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;6&quot; &gt; proc.txt</span><br><span class="line">ParaAT.pl -h single_copy.txt.change -a all.pep.fa -n all.cds.fa -o Para_out -p proc.txt</span><br><span class="line"></span><br><span class="line">-h single_copy.txt \ #基因家族信息，每一行一个家族</span><br><span class="line">-a all.pep.fa \ #全部蛋白序列</span><br><span class="line">-n all.cds.fa \ #全部cds序列</span><br><span class="line">-o Para_out \ #输出结果目录</span><br><span class="line">-p proc.txt #指定线程数文件</span><br></pre></td></tr></table></figure>
<p>注意protein文件和cds文件名称必须与single_copy.txt.change一致，为保证这一点可以进行以下操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#简化序列名</span><br><span class="line">sed -i &#x27;/^&gt;/ s/ .*//&#x27; changepep/*.fa.change</span><br><span class="line">#直接将cds翻译成protein保证名称一致</span><br><span class="line">for i in cds/*.fa ;do</span><br><span class="line">base=$(basename &quot;$i&quot; .fa);</span><br><span class="line">seqkit translate &quot;$i&quot; &gt; pep/&quot;$base.fa&quot;;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>除此之外，序列名称不允许包含|，：，-等特殊字符，并且序列数也有限制，因此只推荐数量较少的进行</p>
<p>序列数较多可以使用Hyphy（<a target="_blank" rel="noopener" href="https://github.com/veg/hyphy-analyses/tree/master/codon-msa">https://github.com/veg/hyphy-analyses/tree/master/codon-msa</a> ）具体流程较为复杂，需要重新编写脚本，不推荐使用</p>
<p>到此分化时间估计就完成了，可视化也是使用ITOL网站，但是由于文件格式原因，不能直接像之前的树文件一样拖入即可，因此需要进行一些修改，此部分在下一篇教程《基因家族扩张收缩》中介绍</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/05/19/%E6%9F%A5%E6%89%BE%E5%85%B1%E6%9C%89%E5%92%8C%E7%8B%AC%E6%9C%89%E5%9F%BA%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Plank">
      <meta itemprop="description" content="白马？定叫他有来无回！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeFun blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/19/%E6%9F%A5%E6%89%BE%E5%85%B1%E6%9C%89%E5%92%8C%E7%8B%AC%E6%9C%89%E5%9F%BA%E5%9B%A0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-05-19 15:53:23 / 修改时间：15:49:43" itemprop="dateCreated datePublished" datetime="2025-05-19T15:53:23+08:00">2025-05-19</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="查找共有独有基因"><a href="#查找共有独有基因" class="headerlink" title="查找共有独有基因"></a>查找共有独有基因</h1><p><strong>为什么要查找共有和独有基因？</strong><br>共有基因一般是同源基因，独有基因是指该物种因为环境而被迫演化出的的基因，这意味这在对应的环境下，必定有一些适应该环境的特殊基因，这可以帮助我们弄清楚物种的之间的演化过程，也可以在育种方面提供原材料。<br>共有基因往往对应的是一些基因家族，在漫长的演化过程中，基因家族中有一些基因减少，或者增多，这其实就对应着基因家族的扩张收缩，这也是研究物种演化的关键数据之一。<br>查找共有和独有基因其实就是做基因家族的聚类，分析基因家族的扩张收缩，常有的软件有orthofinder和orthomcl，orthofinder的集成度更好，还可以自动完成建树因此此处我们学习orthofinder的使用。  </p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>下载和官方教程地址：<a target="_blank" rel="noopener" href="https://github.com/davidemms/OrthoFinder">https://github.com/davidemms/OrthoFinder</a><br>可以使用conda安装  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install orthofinder -c bioconda</span><br></pre></td></tr></table></figure>
<p>也可以手动安装  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/davidemms/OrthoFinder/releases/latest/download/OrthoFinder.tar.gz</span><br><span class="line">tar xzvf OrthoFinder.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="2-准备数据"><a href="#2-准备数据" class="headerlink" title="2.准备数据"></a>2.准备数据</h2><p>本次所使用的数据是Magnolia_biondii.chr.pep和Msin.chr.pep两物种的蛋白质数据，但这两个数据往往不可以直接获得，就算直接获得的，也往往不是最长转录本，因此我们先要进行一些处理<br>首先需要根据数据提取最长转录本<br><strong>为什么要提取最长转录本？</strong><br>由于可变剪切的存在，通常一个基因可以转录为多个转录本。但是如果将多个转录本同时进行分析，那么分析会因此受到影响。所以，目前的解决办法是，选取一个最具代表性的转录本（最长转录本）来进行分析。<br>最长转录本其实可以从序列文件中获取，也可以从gff文件中获取，获取的方式也有很多，可以直接使用gettranstool，用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetLongestTransFromGencode --file example.fa --outfile longest_trans_gencode.fa</span><br></pre></td></tr></table></figure>
<p>官方的教程：<a target="_blank" rel="noopener" href="https://github.com/junjunlab/GetTransTool%EF%BC%8C%E6%9C%89%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%8F%AF%E4%BB%A5%E6%9F%A5%E9%98%85">https://github.com/junjunlab/GetTransTool，有需要自己可以查阅</a><br>在此介绍对于小白最友好的方法，即使用之前提过多次的软件，TBtools：  </p>
<pre><code>sequence toolkit-&gt;fasta tools-&gt;fasta get representative  
</code></pre>
<p>note部分不需要管，ID grouping pattern处为正则表达式，这是序列名称的编号规则，一般不需要更改，然后是输入蛋白质序列数据以及输出文件名的设置<br>建议直接使用TBtools最简单，只需要弄清楚ID号的正则表达式即可  </p>
<p>##蛋白质序列的序列名应该尽量简单，否则可能会出现报错</p>
<pre><code>ValueError: too many values to unpack
</code></pre>
<p>这种情况一般在10个以上物种进行聚类的时候出现，出现这种情况时，可以直接使用python脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">from Bio import SeqIO</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def simplify_fasta_headers(input_file, output_file):</span><br><span class="line">    &quot;&quot;&quot;简化单个FASTA文件的序列头，保留第一个有效标识符&quot;&quot;&quot;</span><br><span class="line">    with open(output_file, &quot;w&quot;) as out_handle:</span><br><span class="line">        for record in SeqIO.parse(input_file, &quot;fasta&quot;):</span><br><span class="line">            new_id = record.id.split()[0]  # 取第一个空格前的部分</span><br><span class="line">            record.id = new_id</span><br><span class="line">            record.description = new_id</span><br><span class="line">            SeqIO.write(record, out_handle, &quot;fasta&quot;)</span><br><span class="line"></span><br><span class="line">def process_directory(input_dir, output_dir):</span><br><span class="line">    &quot;&quot;&quot;批量处理目录下所有.fasta文件&quot;&quot;&quot;</span><br><span class="line">    if not os.path.exists(output_dir):</span><br><span class="line">        os.makedirs(output_dir)</span><br><span class="line"></span><br><span class="line">    for filename in os.listdir(input_dir):</span><br><span class="line">        if filename.endswith(&quot;.fasta&quot;) or filename.endswith(&quot;.fa&quot;):</span><br><span class="line">            input_path = os.path.join(input_dir, filename)</span><br><span class="line">            output_path = os.path.join(output_dir, filename)</span><br><span class="line">            simplify_fasta_headers(input_path, output_path)</span><br><span class="line">            print(f&quot;处理完成: &#123;filename&#125; -&gt; &#123;output_path&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    if len(sys.argv) != 3:</span><br><span class="line">        print(f&quot;用法: &#123;sys.argv[0]&#125; &lt;输入文件夹&gt; &lt;输出文件夹&gt;&quot;)</span><br><span class="line">        print(f&quot;示例: &#123;sys.argv[0]&#125; ./input_fasta ./cleaned_fasta&quot;)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    input_dir = sys.argv[1]</span><br><span class="line">    output_dir = sys.argv[2]</span><br><span class="line">    process_directory(input_dir, output_dir)</span><br><span class="line">    print(f&quot;\n所有文件处理完成！结果保存在: &#123;output_dir&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>该脚本是终端脚本，使用方式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python simplify_headers.py ./原始文件夹 ./输出文件夹</span><br></pre></td></tr></table></figure>
<p>删除所有非标准氨基酸字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in data4/*;do sed -i &#x27;/^&gt;/! s/[^A-Za-z]//g&#x27; &quot;$i&quot;; done</span><br></pre></td></tr></table></figure>
<h2 id="3-家族聚类及结果解读"><a href="#3-家族聚类及结果解读" class="headerlink" title="3.家族聚类及结果解读"></a>3.家族聚类及结果解读</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">orthofinder -f data -S diamond -M msa -T fasttree -t 20 </span><br><span class="line">-f： 数据目录，先将所有蛋白放进文件夹data中</span><br><span class="line">-S： 比对方法，blast, mmseqs, blast_gz, diamond</span><br><span class="line">-M： 基因树推断方法，dendroblast，msa</span><br><span class="line">-T：建树软件，iqtree, raxml-ng, fasttree, raxml</span><br><span class="line">-t： 线程数，根据服务器配置选择，默认为56</span><br></pre></td></tr></table></figure>
<p>聚类结果如下：</p>
<pre><code>Results_XX #结果文件夹名
Citation.txt
Comparative_Genomics_Statistics #统计结果
Gene_Duplication_Events
Gene_Trees # 每个家族基因树
Log.txt
MultipleSequenceAlignments # 多序列比对结果 包含单拷贝基因supergene
Orthogroups # 主要结果目录
Orthogroup_Sequences # 每个家族序列文件
Orthologues
Phylogenetically_Misplaced_Genes
Phylogenetic_Hierarchical_Orthogroups
Putative_Xenologs
Resolved_Gene_Trees
Single_Copy_Orthologue_Sequences # 单拷贝基因家族序列
Species_Tree # 物种树构建结果
WorkingDirectory

Results_XX/Orthogroups#主要结果
Orthogroups.GeneCount.tsv # 基因数目
Orthogroups_SingleCopyOrthologues.txt # 单拷贝基因家族列表
Orthogroups.tsv # 聚类结果
Orthogroups.txt # 聚类结果
Orthogroups_UnassignedGenes.tsv # 未聚类基因
</code></pre>
<h2 id="4-处理聚类结果并绘制韦恩图"><a href="#4-处理聚类结果并绘制韦恩图" class="headerlink" title="4.处理聚类结果并绘制韦恩图"></a>4.处理聚类结果并绘制韦恩图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123; if(NR==1)&#123; for(i=2;i&lt;NF;i++ )&#123;printf $i&quot;\t&quot;&#125; &#125;else&#123; \</span><br><span class="line">for(i=2;i&lt;NF;i++)&#123; if($i&gt;0)&#123;printf $1 &#125; ; printf &quot;\t&quot; &#125;&#125;; \</span><br><span class="line">printf &quot;\n&quot;&#125;&#x27; Orthogroups.GeneCount.tsv | \</span><br><span class="line">sed &#x27;s/\t$//&#x27; &gt; Orthogroups.GeneCount.venn</span><br></pre></td></tr></table></figure>
<p>脚本解释：  </p>
<pre><code>NR==1: 当读取到文件的第一行时（通常是列标题行），执行以下操作：
    for(i=2;i&lt;NF;i++): 从第2列开始（跳过第1列），循环处理每一列直到倒数第2列。
    printf $i&quot;\t&quot;: 输出每列的内容，后面跟一个制表符（\t），这些输出结果是列标题（从第2列开始），将用于标记维恩图中不同组的名称。
    else&#123; for(i=2;i&lt;NF;i++)&#123; if($i&gt;0)&#123;printf $1 &#125;; printf &quot;\t&quot; &#125;&#125;
非第一行时
    for(i=2;i&lt;NF;i++): 对每一行，从第2列开始直到倒数第2列进行循环。
    if($i&gt;0)&#123;printf $1 &#125;: 如果当前列的值大于0，则输出该行的第1列内容（通常是一个基因组的名称或ID）。
    printf &quot;\t&quot;: 在输出内容之后，加入一个制表符。
</code></pre>
<p>每处理完一行后，脚本在行尾输出一个换行符（\n），以确保每行的数据换行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/\t$//&#x27;</span><br><span class="line">    sed命令用于对awk生成的输出进行后处理。s/\t$//是一个替换操作：</span><br><span class="line">        \t$表示行末的制表符（\t）。</span><br><span class="line">        //表示将匹配到的行末制表符删除。</span><br></pre></td></tr></table></figure>
<p>或者直接使用dos2unix进行转换</p>
<p>处理好的.venn文件可以直接拿来做韦恩图，可以使用在线网站也可以用R，通常情况下我会使用jvenn网站绘制完，根据数据使用AI自己重新绘制一个<br>jvenn网址：<a target="_blank" rel="noopener" href="https://jvenn.toulouse.inrae.fr/app/example.html">https://jvenn.toulouse.inrae.fr/app/example.html</a><br>下面介绍使用R绘制<br>下面是脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 加载必要的库</span><br><span class="line">library(ggVennDiagram)</span><br><span class="line">library(ggplot2)</span><br><span class="line"></span><br><span class="line"># 读取文件数据</span><br><span class="line">file_path &lt;- &quot;Orthogroups.GeneCount.venn&quot;  # 请根据实际文件路径进行替换</span><br><span class="line">data &lt;- read.table(file_path, header = TRUE, sep = &quot;\t&quot;, stringsAsFactors = FALSE)</span><br><span class="line"></span><br><span class="line"># 提取非空值的集合</span><br><span class="line">set_JNYL &lt;- data$JNYL[data$JNYL != &quot;&quot;]</span><br><span class="line">set_WCYL &lt;- data$WCYL[data$WCYL != &quot;&quot;]</span><br><span class="line"></span><br><span class="line"># 创建集合列表</span><br><span class="line">sets &lt;- list(</span><br><span class="line">  JNYL = set_JNYL,</span><br><span class="line">  WCYL = set_WCYL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 使用ggVennDiagram绘制维恩图</span><br><span class="line">ggVennDiagram(sets,</span><br><span class="line">              category.names = c(&quot;JNYL&quot;, &quot;WCYL&quot;), # 集合名字</span><br><span class="line">              set_color = c(&quot;blue&quot;, &quot;red&quot;),       # 集合颜色</span><br><span class="line">              set_size = 6,                       # 集合名字大小</span><br><span class="line">              label = &quot;both&quot;,                     # 标签显示&quot;count&quot;和&quot;percent&quot;</span><br><span class="line">              label_geom = &quot;label&quot;,               # 标签样式</span><br><span class="line">              label_alpha = 0,                    # 标签背景透明</span><br><span class="line">              label_color = &quot;firebrick&quot;,          # 标签颜色</span><br><span class="line">              label_percent_digit = 2,            # 百分比保留2位小数</span><br><span class="line">              edge_lty = &quot;dashed&quot;,                # 边框线型</span><br><span class="line">              edge_size = 1.2                     # 边框粗细</span><br><span class="line">) +</span><br><span class="line">  scale_fill_gradient(low = &quot;grey90&quot;, high = &quot;grey60&quot;) +  # 填充色</span><br><span class="line">  scale_color_manual(values = c(&quot;grey10&quot;, &quot;grey10&quot;))      # 边框颜色</span><br><span class="line"></span><br><span class="line">结果可以使用ggplot2进行优化，这也是为什么要调用ggplot2的原因个人感觉其实到这就可以了</span><br><span class="line">#先将文件转为数据框</span><br><span class="line">venn &lt;- Venn(sets)</span><br><span class="line">df &lt;- process_data(venn)</span><br><span class="line">df</span><br><span class="line">#ggplot2绘图</span><br><span class="line">ggplot()+</span><br><span class="line">  geom_sf(data = venn_region(df), aes(fill=count))+</span><br><span class="line">  geom_sf(data = venn_setedge(df),size=2,lty=&quot;dashed&quot;,color=&quot;grey&quot;)+</span><br><span class="line">  geom_sf(data = venn_setlabel(df),aes(label=name))+</span><br><span class="line">  geom_sf_label(data = venn_region(df),aes(label=id),fontface=&quot;bold&quot;)+</span><br><span class="line">  scale_fill_distiller(palette = 5)+</span><br><span class="line">  theme_void()</span><br></pre></td></tr></table></figure>
<p>其实到这我对图还是不满意，我后面又用AI换了一下颜色</p>
<p><strong>提取独有共有基因的OGid</strong><br>使用jvenn，点击venn图中想要继续分析的区域的数字，即可获得该区域内的所有OGid</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#将OGid与基因名相匹配</span><br><span class="line">cp ../../Results_May02/Orthogroups/Orthogroups.tsv ./	#将之前结果文件复制到当前目录下</span><br><span class="line">grep -f Ms.txt Orthogroups.tsv | cut -f3 | sed &quot;s/ /\n/g&quot; | sed &quot;s/\t/\n/g&quot; | sed &quot;s/,//g&quot; | sort | uniq &gt; Ms.specific	</span><br><span class="line">#Ms.txt是得到的OGid，必须是unix格式，即使用cat -A打开后结尾是^I^M$，如果不是使用dos2unix转换一下</span><br><span class="line">	-f表示从文件中读取关键词</span><br><span class="line">	| cut -f3 cut 用于按列提取内容，-f3 表示提取每行的第 3 列，因为Ms在Orthogroups.tsv的第三列</span><br><span class="line">&quot;s/ /\n/g&quot;：</span><br><span class="line">    s：表示替换命令。</span><br><span class="line">    / /：表示匹配空格字符。</span><br><span class="line">    \n：表示将空格替换为换行符。</span><br><span class="line">    g：表示全局替换，即替换行中所有的空格</span><br><span class="line">| sed &quot;s/\t/\n/g&quot;：将制表符（\t）替换为换行符</span><br><span class="line">| sed &quot;s/,//g&quot;：将逗号（,）移除</span><br><span class="line">| sort：用于对文本内容进行排序</span><br><span class="line">| uniq： 用于去除相邻的重复行</span><br></pre></td></tr></table></figure>
<p>提取得到基因列表，可以按之前的教程继续后面的GO、KEGG分析</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/18/circos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Plank">
      <meta itemprop="description" content="白马？定叫他有来无回！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WeFun blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/18/circos/" class="post-title-link" itemprop="url">circos图的绘制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-18 20:02:45" itemprop="dateCreated datePublished" datetime="2025-04-18T20:02:45+08:00">2025-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-19 11:05:59" itemprop="dateModified" datetime="2025-04-19T11:05:59+08:00">2025-04-19</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>绘制circos图可以使用circos软件在服务器中运行，也可以使用TBtools，两者出图没有本质的区别，在此先介绍对小白更友好，操作更简单的TBtools，但是一些文件的获得依旧需要依靠服务器.  后面介绍circos软件的使用<br>教程来源主要为：<a target="_blank" rel="noopener" href="https://www.yuque.com/cjchen/hirv8i/b88df7179632c0ee5f86a4b74a58f933">https://www.yuque.com/cjchen/hirv8i/b88df7179632c0ee5f86a4b74a58f933</a><br>此外含有大量个人经验，仅看本教程完全可以完成全部工作</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/04/18/circos/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Plank"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Plank</p>
  <div class="site-description" itemprop="description">白马？定叫他有来无回！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plank</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">54k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">49 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
